#!/bin/bash

# Copyright AppsCode Inc. and Contributors
#
# Licensed under the AppsCode Community License 1.0.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://github.com/appscode/licenses/raw/1.0.0/AppsCode-Community-1.0.0.md
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -eou pipefail

# Generated by render-gotpl. DO NOT EDIT.
# Make your desired changes in the files in the templates directory and run `make gen fmt`.

CATALOGS=(
    stash-elasticsearch
    stash-mariadb
    stash-mongodb
    stash-mysql
    stash-percona-xtradb
    stash-postgres
)

ELASTICSEARCH_VERSIONS=(
    5.6.4-v6
    6.2.4-v6
    6.3.0-v6
    6.4.0-v6
    6.5.3-v6
    6.8.0-v6
    7.2.0-v6
    7.3.2-v6
)

MARIADB_VERSIONS=(
    10.5.8
)

MONGODB_VERSIONS=(
    3.4.17-v5
    3.4.22-v5
    3.6.8-v5
    3.6.13-v5
    4.0.3-v5
    4.0.5-v5
    4.0.11-v5
    4.1.4-v5
    4.1.7-v5
    4.1.13-v5
    4.2.3-v5
)

MYSQL_VERSIONS=(
    5.7.25-v6
    8.0.3-v6
    8.0.14-v6
    8.0.21
)

PERCONA_XTRADB_VERSIONS=(
    5.7.0-v1
)

POSTGRES_VERSIONS=(
    9.6.19-v4
    10.14.0-v4
    11.9.0-v4
    12.4.0-v4
    13.1.0-v1
)

OS=""
ARCH=""
DOWNLOAD_URL=""
DOWNLOAD_DIR=""
TEMP_DIRS=()

HELM=""
HELM_HOME=$HOME/.helm
HELM_VALUES=()

CATALOG_VARIANT="all"
CATALOG_VERSION=""

APPSCODE_ENV=${APPSCODE_ENV:-prod}
APPSCODE_CHART_REGISTRY=${APPSCODE_CHART_REGISTRY:-"appscode"}
APPSCODE_CHART_REGISTRY_URL=${APPSCODE_CHART_REGISTRY_URL:-"https://charts.appscode.com/stable/"}

DOCKER_REGISTRY=${REGISTRY:-stashed}
DOCKER_IMAGE=""
DOCKER_TAG=""

BACKUP_ARGS=""
RESTORE_ARGS=""

UNINSTALL=0

function cleanup() {
    # remove temporary directories
    # ref: https://gist.github.com/dimo414/2fb052d230654cc0c25e9e41a9651ebe
    for dir in ${TEMP_DIRS[@]+"${TEMP_DIRS[@]}"}; do
        rm -rf "${dir}"
    done
}

# detect operating system
function detectOS() {
    OS=$(echo $(uname) | tr '[:upper:]' '[:lower:]')

    case "$OS" in
        # Minimalist GNU for Windows
        cygwin* | mingw* | msys*) OS='windows' ;;
    esac
}

# detect machine architecture
function detectArch() {
    ARCH=$(uname -m)
    case $ARCH in
        armv5*) ARCH="armv5" ;;
        armv6*) ARCH="armv6" ;;
        armv7*) ARCH="arm" ;;
        aarch64) ARCH="arm64" ;;
        x86) ARCH="386" ;;
        x86_64) ARCH="amd64" ;;
        i686) ARCH="386" ;;
        i386) ARCH="386" ;;
    esac
}

detectOS
detectArch

# download file pointed by DOWNLOAD_URL variable
# store download file to the directory pointed by DOWNLOAD_DIR variable
# you have to sent the output file name as argument. i.e. downloadFile myfile.tar.gz
function downloadFile() {
    if curl --output /dev/null --silent --head --fail "${DOWNLOAD_URL}"; then
        curl -fsSL ${DOWNLOAD_URL} -o ${DOWNLOAD_DIR}/$1
    else
        echo "File does not exist"
        exit 1
    fi
}

function array_contains() {
    local array="$1[@]"
    local seeking=$2
    local in=1
    for element in "${!array}"; do
        if [[ $element == $seeking ]]; then
            in=0
            break
        fi
    done
    return $in
}

function catalog_version_supported() {
    local catalog_variant=$1
    local version=$2

    case "$catalog_variant" in
        "stash-postgres")
            if array_contains POSTGRES_VERSIONS $version; then
                return 0
            else
                return 1
            fi
            ;;
        "stash-mongodb")
            if array_contains MONGODB_VERSIONS $version; then
                return 0
            else
                return 1
            fi
            ;;
        "stash-elasticsearch")
            if array_contains ELASTICSEARCH_VERSIONS $version; then
                return 0
            else
                return 1
            fi
            ;;
        "stash-mysql")
            if array_contains MYSQL_VERSIONS $version; then
                return 0
            else
                return 1
            fi
            ;;
        "stash-mariadb")
            if array_contains MARIADB_VERSIONS $version; then
                return 0
            else
                return 1
            fi
            ;;
        "stash-percona-xtradb")
            if array_contains PERCONA_XTRADB_VERSIONS $version; then
                return 0
            else
                return 1
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

trap cleanup EXIT

show_help() {
    echo "setup.sh - install catalog for stash"
    echo " "
    echo "setup.sh [options]"
    echo " "
    echo "options:"
    echo "-h, --help                          show brief help"
    echo "    --catalog                       specify a specific catalog variant to install."
    echo "    --version                       specify a specific version of a specific catalog to install. use it along with '--catalog' flag."
    echo "    --docker-registry               specify the docker registry to use to pull respective catalog images. default value: 'stashed'.   "
    echo "    --image                         specify the name of the docker image to use for respective catalogs."
    echo "    --image-tag                     specify the tag of the docker image to use for respective catalog."
    echo "    --backup-args                   specify optional arguments to pass to the respective backup command."
    echo "    --restore-args                  specify optional arguments to pass to the respective restore command"
    echo "    --uninstall                     uninstall specific or all catalogs."
}

while test $# -gt 0; do
    case "$1" in
        -h | --help)
            show_help
            exit 0
            ;;
        --catalog*)
            variant=$(echo $1 | sed -e 's/^[^=]*=//g')
            CATALOG_VARIANT=$variant
            shift
            ;;
        --version*)
            version=$(echo $1 | sed -e 's/^[^=]*=//g')
            CATALOG_VERSION=$version
            shift
            ;;
        --docker-registry*)
            DOCKER_REGISTRY=$(echo $1 | sed -e 's/^[^=]*=//g')
            shift
            ;;
        --image-tag*)
            DOCKER_TAG=$(echo $1 | sed -e 's/^[^=]*=//g')
            shift
            ;;
        --image*)
            DOCKER_IMAGE=$(echo $1 | sed -e 's/^[^=]*=//g')
            shift
            ;;
        --backup-args*)
            BACKUP_ARGS=$(echo $1 | sed -e 's/^[^=]*=//g')
            shift
            ;;
        --restore-args*)
            RESTORE_ARGS=$(echo $1 | sed -e 's/^[^=]*=//g')
            shift
            ;;
        --uninstall*)
            UNINSTALL=1
            shift
            ;;
        *)
            echo "unknown flag: $1"
            echo " "
            show_help
            exit 1
            ;;
    esac
done

# check whether catalog variant is supported or not
if [[ $CATALOG_VARIANT != "all" ]]; then
    if ! array_contains CATALOGS $CATALOG_VARIANT; then
        echo "Catalog $CATALOG_VARIANT is not supported"
        exit 1
    else
        CATALOGS=($CATALOG_VARIANT)
    fi
fi

# check whether specified version is supported for respective catalog variant
if [[ $CATALOG_VERSION != "" ]]; then
    if ! catalog_version_supported $CATALOG_VARIANT $CATALOG_VERSION; then
        echo "Catalog $CATALOG_VARIANT does not have version $CATALOG_VERSION"
        exit 1
    fi
fi

# Download helm if the desried version is not installed
function ensure_helm() {
    HELM_VERSION="$1"

    # if the desrired version is already installed then use it
    if [ -x "$(command -v helm)" ]; then
        helm_version=$(helm version --short 2>/dev/null || true)
        installed_version="$(echo $helm_version | head -c2 || test $? -eq 141)" # take only the major part of the version
        desired_version="$(echo $HELM_VERSION | head -c2 || test $? -eq 141)"   # take only the major part of the version
        if [[ "${installed_version}" == "${desired_version}" ]]; then
            HELM=helm
            return # desired version is present. so, no need to download.
        fi
    fi

    echo "Helm $HELM_VERSION is not installed!. Downloading....."
    ARTIFACT="https://get.helm.sh"
    HELM_BIN=helm
    HELM_DIST=${HELM_BIN}-${HELM_VERSION}-${OS}-${ARCH}.tar.gz

    case "$OS" in
        cygwin* | mingw* | msys*)
            HELM_BIN=${HELM_BIN}.exe
            ;;
    esac

    DOWNLOAD_URL=${ARTIFACT}/${HELM_DIST}
    DOWNLOAD_DIR="$(mktemp -dt helm-XXXXXX)"
    TEMP_DIRS+=($DOWNLOAD_DIR)
    downloadFile ${HELM_DIST}

    tar xf ${DOWNLOAD_DIR}/${HELM_DIST} -C ${DOWNLOAD_DIR}
    HELM=${DOWNLOAD_DIR}/${OS}-${ARCH}/${HELM_BIN}
    chmod +x $HELM

    # Set HELM_HOME to a temporary directory
    export HELM_HOME=$DOWNLOAD_DIR/.helm
}

# generate values flags with provided input
# ========== common values =================
if [[ $DOCKER_REGISTRY != "" ]]; then
    HELM_VALUES+=("--set image.registry=$DOCKER_REGISTRY")
fi

if [[ $DOCKER_IMAGE != "" ]]; then
    HELM_VALUES+=("--set image.repository=$DOCKER_IMAGE")
fi

if [[ $DOCKER_TAG != "" ]]; then
    HELM_VALUES+=("--set image.tag=$DOCKER_TAG")
fi

# ========== catalog specific values =================
if [[ $BACKUP_ARGS != "" ]]; then
    HELM_VALUES+=("--set backup.args=$BACKUP_ARGS")
fi
if [[ $RESTORE_ARGS != "" ]]; then
    HELM_VALUES+=("--set restore.args=$RESTORE_ARGS")
fi

# create a temporary directory to store charts files
TEMP_CHART_DIR="$(mktemp -dt appscode-XXXXXX)"
TEMP_DIRS+=(${TEMP_CHART_DIR})

# Ensure Helm binary
ensure_helm "v3.3.4"

# Add AppsCode chart registry
$HELM repo add "${APPSCODE_CHART_REGISTRY}" "${APPSCODE_CHART_REGISTRY_URL}"
$HELM repo update

function install_catalog() {
    local catalog="$1"
    local version="$2"

    # render template then pipe to "kubectl apply" command
    $HELM template "${TEMP_CHART_DIR}"/"${catalog}" ${HELM_VALUES[@]} |
        kubectl apply -f -
}

function uninstall_catalog() {
    local catalog="$1"
    local version="$2"

    # render template then pipe to "kubectl delete" command
    $HELM template "${TEMP_CHART_DIR}"/"${catalog}" |
        kubectl delete -f -
}

function handle_catalog() {
    local catalog="$1"
    # ref: https://askubuntu.com/a/995110
    shift
    local versions=("$@")

    for version in "${versions[@]}"; do
        # download chart from remote repository and extract into the temporary directory we have created earlier
        $HELM fetch --untar "${APPSCODE_CHART_REGISTRY}"/"${catalog}" \
            --untardir "${TEMP_CHART_DIR}" \
            --version="${version}"

        if [[ "${UNINSTALL}" == "1" ]]; then
            uninstall_catalog "${catalog}" "${version}"
        else
            install_catalog "${catalog}" "${version}"
        fi

        # remove the chart so that new version of this chart can be downloaded
        rm -rf ${TEMP_CHART_DIR}/${catalog}
    done
}

catalog_versions=()
for catalog in "${CATALOGS[@]}"; do
    case "${catalog}" in
        "stash-postgres")
            if [[ "${CATALOG_VERSION}" != "" ]]; then
                catalog_versions=("${CATALOG_VERSION}")
            else
                catalog_versions=(${POSTGRES_VERSIONS[@]})
            fi
            ;;
        "stash-mongodb")
            if [[ "${CATALOG_VERSION}" != "" ]]; then
                catalog_versions=("${CATALOG_VERSION}")
            else
                catalog_versions=(${MONGODB_VERSIONS[@]})
            fi
            ;;
        "stash-elasticsearch")
            if [[ "${CATALOG_VERSION}" != "" ]]; then
                catalog_versions=("${CATALOG_VERSION}")
            else
                catalog_versions=(${ELASTICSEARCH_VERSIONS[@]})
            fi
            ;;
        "stash-mysql")
            if [[ "${CATALOG_VERSION}" != "" ]]; then
                catalog_versions=("${CATALOG_VERSION}")
            else
                catalog_versions=(${MYSQL_VERSIONS[@]})
            fi
            ;;
        "stash-mariadb")
            if [[ "${CATALOG_VERSION}" != "" ]]; then
                catalog_versions=("${CATALOG_VERSION}")
            else
                catalog_versions=(${MARIADB_VERSIONS[@]})
            fi
            ;;
        "stash-percona-xtradb")
            if [[ "${CATALOG_VERSION}" != "" ]]; then
                catalog_versions=("${CATALOG_VERSION}")
            else
                catalog_versions=(${PERCONA_XTRADB_VERSIONS[@]})
            fi
            ;;
        *)
            echo "Unrecognized catalog: ${catalog}"
            exit 1
            ;;
    esac

    # install/uninstall this catalog
    handle_catalog "${catalog}" "${catalog_versions[@]}"
done
